function documentUpload(url: string, data?: any, httpOptions?: any): Promise<any> {
  const headers = (httpOptions && httpOptions.headers) || {};
  const started = Date.now();
  const timestamp = () => new Date().toISOString();
  const elapsed = () => `${Date.now() - started} ms`;

  // Request start
  console.log(`[${timestamp()} | +${elapsed()}] [FETCH REQUEST START] URL: ${url}`);

  return fetch(url, {
    method: 'POST',
    headers,
    body: data
  })
    .then(async response => {
      // Response start
      console.log(`[${timestamp()} | +${elapsed()}] [FETCH RESPONSE START] URL: ${url} Status: ${response.status}`);

      // Request end (using Performance API for real upload duration)
      setTimeout(() => {
        const entry = performance.getEntriesByType("resource")
          .reverse()
          .find(e => (e as PerformanceResourceTiming).name.includes(url)) as PerformanceResourceTiming;

        if (entry) {
          const uploadTime = entry.responseStart - entry.requestStart; // ms
          console.log(`[${timestamp()}] [FETCH REQUEST END] URL: ${url} Time: ${uploadTime.toFixed(2)} ms`);
        } else {
          console.warn(`[${timestamp()}] [FETCH REQUEST END] Could not determine exact timing for URL: ${url}`);
        }
      }, 60);

      // Parse body
      const body = await response.json();

      // Response end
      console.log(`[${timestamp()} | +${elapsed()}] [FETCH RESPONSE END] URL: ${url}`);
      return body;
    })
    .catch(error => {
      console.error(`[${timestamp()} | +${elapsed()}] [FETCH REQUEST END WITH ERROR] URL: ${url}`, error);
      throw error;
    });
}
