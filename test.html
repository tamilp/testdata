import {
  HttpEvent,
  HttpEventType,
  HttpInterceptorFn,
  HttpRequest,
  HttpHandlerFn
} from '@angular/common/http';
import { tap } from 'rxjs';

/* ---------- helpers ---------- */
function padRight(s: string, len = 40) { return s + ' '.repeat(Math.max(0, len - s.length)); }
function formatClock(msEpoch: number) {
  return new Date(msEpoch).toISOString().split('T')[1].replace('Z', ''); // HH:mm:ss.SSS
}
function fmtMs(v: number) { return `${v.toFixed(2)} ms`; }

/**
 * Render a simple ASCII bar based on durations.
 * longestDuration maps to width chars; others scale proportionally.
 */
function renderBars(requestSent: number, waiting: number, download: number, width = 40) {
  const max = Math.max(requestSent, waiting, download, 1);
  const r = Math.round((requestSent / max) * width);
  const w = Math.round((waiting / max) * width);
  const d = Math.round((download / max) * width);

  const bar = (n: number, ch = 'â–ˆ') => ch.repeat(Math.max(1, n));
  return {
    requestBar: bar(r, 'â–‡'),
    waitingBar: bar(w, 'â–‡'),
    downloadBar: bar(d, 'â–‡')
  };
}

/* ---------- find resource timing entry ---------- */
function findResourceTiming(reqUrl: string): PerformanceResourceTiming | undefined {
  try {
    const target = new URL(reqUrl, location.href).href;
    const byName = performance.getEntriesByName(target) as PerformanceResourceTiming[];
    if (byName && byName.length) return byName[byName.length - 1];

    const entries = performance.getEntriesByType('resource') as PerformanceResourceTiming[];
    for (let i = entries.length - 1; i >= 0; i--) {
      const e = entries[i];
      if (!e.name) continue;
      if (e.name === target || e.name.includes(reqUrl) || target.includes(e.name)) return e;
    }
  } catch (_) { /* ignore */ }
  return undefined;
}

/* ---------- main logging that replicates DevTools image ---------- */
function logDevToolsStyle(reqUrl: string) {
  // short delay so the browser adds the resource timing entry
  setTimeout(() => {
    const entry = findResourceTiming(reqUrl);
    if (!entry) {
      console.warn(`No PerformanceResourceTiming entry found for: ${reqUrl}`);
      return;
    }

    // convert performance timing (relative to navigationStart) to epoch ms
    const navStartEpoch = Date.now() - performance.now();
    const abs = (t: number) => navStartEpoch + t;

    // Fields from PerformanceResourceTiming
    const startTime = entry.startTime;         // resource fetch start
    const requestStart = entry.requestStart;   // when browser starts sending request bytes
    const responseStart = entry.responseStart; // TTFB (first response byte)
    const responseEnd = entry.responseEnd;     // response fully downloaded

    // Compute durations (ms)
    // NOTE: requestSent = time spent uploading/sending request bytes â‰ˆ requestStart - startTime
    // waiting = server processing / TTFB = responseStart - requestStart
    // download = responseEnd - responseStart
    const requestSent = Math.max(0, requestStart - startTime);
    const waiting = Math.max(0, responseStart - requestStart);
    const download = Math.max(0, responseEnd - responseStart);
    const total = Math.max(0, responseEnd - startTime);

    // build bars proportional to largest phase
    const bars = renderBars(requestSent, waiting, download, 40);

    // Print header like the screenshot
    console.log(`\n[ðŸ“¡ Network timing for ${reqUrl}]`);
    // Request Sent
    console.log(`Request sent             ${padRight(bars.requestBar, 45)} ${fmtMs(requestSent)}`);
    // Waiting
    console.log(`Waiting for server response ${padRight(bars.waitingBar, 45)} ${fmtMs(waiting)}`);
    // Content Download
    console.log(`Content Download         ${padRight(bars.downloadBar, 45)} ${fmtMs(download)}`);
    // Final total (right aligned)
    console.log(`${' '.repeat(60)}Total: ${fmtMs(total)}\n`);

    // Also print exact wall-clock start/end for each phase (optional)
    console.log(
      `  Request Sent Start : ${formatClock(abs(requestStart - requestSent))}` +
      `  End: ${formatClock(abs(requestStart))}`
    );
    console.log(
      `  Waiting Start      : ${formatClock(abs(requestStart)  )}` +
      `  End: ${formatClock(abs(responseStart))}`
    );
    console.log(
      `  Content Download Start : ${formatClock(abs(responseStart))}` +
      `  End: ${formatClock(abs(responseEnd))}`
    );
  }, 60);
}

/* ---------- interceptor ---------- */
export const detailedLoggingInterceptor: HttpInterceptorFn =
  (req: HttpRequest<unknown>, next: HttpHandlerFn) => {
    const hrStart = performance.now();
    const nowStr = () => new Date().toISOString().split('T')[1].replace('Z', '');
    const elapsed = () => `${(performance.now() - hrStart).toFixed(3)} ms`;
    console.log(`[${nowStr()} | +${elapsed()}] [REQUEST START] ${req.method} ${req.urlWithParams}`);

    return next(req).pipe(
      tap({
        next: (event: HttpEvent<unknown>) => {
          if (event.type === HttpEventType.Response) {
            console.log(`[${nowStr()} | +${elapsed()}] [RESPONSE END] ${req.method} ${req.urlWithParams}`);
            logDevToolsStyle(req.urlWithParams);
          }
        },
        error: (err) => {
          console.error(`[${nowStr()} | +${elapsed()}] [RESPONSE ERROR] ${req.method} ${req.urlWithParams}`, err);
          logDevToolsStyle(req.urlWithParams);
        }
      })
    );
  };
