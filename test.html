function documentUpload(url: string, data?: any, httpOptions?: any): Promise<any> {
  const headers = (httpOptions && httpOptions.headers) || {};
  const timestamp = () => new Date().toISOString();

  console.log(`[${timestamp()}] [FETCH REQUEST START] URL: ${url}`);

  return fetch(url, {
    method: 'POST',
    headers,
    body: data
  })
    .then(async response => {
      console.log(`[${timestamp()}] [FETCH RESPONSE START] URL: ${url} Status: ${response.status}`);

      const body = await response.json();

      // Defer logging to ensure PerformanceEntry is available
      setTimeout(() => {
        const entry = performance.getEntriesByType("resource")
          .reverse()
          .find(e => (e as PerformanceResourceTiming).name.includes(url)) as PerformanceResourceTiming;

        if (entry) {
          const requestSent = entry.requestStart - entry.startTime;
          const waiting = entry.responseStart - entry.requestStart;
          const download = entry.responseEnd - entry.responseStart;
          const total = entry.responseEnd - entry.startTime;

          console.log(`\n[ðŸ“¡ Network timing for ${url}]`);
          console.log(`  Request sent             ${requestSent.toFixed(2)} ms`);
          console.log(`  Waiting for server resp  ${waiting.toFixed(2)} ms`);
          console.log(`  Content Download         ${download.toFixed(2)} ms`);
          console.log(`  Total                    ${total.toFixed(2)} ms\n`);
        } else {
          console.warn(`[${timestamp()}] No Performance entry found for URL: ${url}`);
        }
      }, 100);

      console.log(`[${timestamp()}] [FETCH RESPONSE END] URL: ${url}`);
      return body;
    })
    .catch(error => {
      console.error(`[${timestamp()}] [FETCH REQUEST END WITH ERROR] URL: ${url}`, error);
      throw error;
    });
}
